템플릿 메서드 패턴과 콜백 패턴
    템플릿 메서드 패턴 - 시작
        코드의 핵심기능과 부가기능

        핵심기능
            해당 객체가 제공하는 고유의 기능.

        부가기능
            핵심 기능을 보조하기 위해 제공되는 기능.

        ★★★변하는 것과 변하지 않는 것을 분리 - 좋은 애플리케이션의 설계의 이상적인 모습

        Controller, Service, Repository의 구조를 보면 로그 추적기를 사용하는 구조는 모두 동일 핵심 기능을 사용하는 코드만 다르다.

        여기서 핵심 기능부분은 변하고, 로그 추적기를 사용하는 부분은 변하지 않는 부분이다!
        이 둘을 분리해서 모듈화 해야하는데

        이런 문제 해결에 적합한 패턴이 템플릿 메서드 패턴이다.

    템플릿 메서드 패턴 - 예제 1
        변하는 부분은 비즈니스로직
        변하지 않는 부분 시간을 측정하는 부분(부가기능,공통기능)

        템플릿 메서드 패턴이 변하는 부분과 변하지 않는 부분을 분리할 수 있다.

    템플릿 메서드 패턴 - 예제 2
        추상 템플릿 -> 변하지 않는 로직들을 모아놓는다. 템플릿은 결국 '틀'이다!

        변하는 부분은 자식클래스로 만든다! 템플릿은 추상메서드이므로 상속받기 가능!

        템플릿 안에서 변하는 부분은 call() 메서드를 호출해서 처리한다!

        변하는 부분은 상속받은곳에서 마음껏 바꾸면서 구현하면되고
        안변하는 부분은 템플릿에 구현되어있으므로 건드릴 필요가 없다.

        관심사를 분리하여 변하는 부분의 범위를 최소화하여 유연성을 높이고 재사용성을 높인다.

    템플릿 메서드 패턴 - 예제 3
        익명 내부 클래스 사용하기!

        템플릿 메서드 패턴은 클래스를 계속 만들어야 하는 단점이 있다! 익명 내부 클래스를  사용하면 이런 단점을 보완할 수 있다.

        객체 인스턴스를 생성하면서 동시에 생성할 클래스를 상속받은 자식 클래스를 정의할 수 있다.

        이름 없고 내부에서 선언되어가지고 익명 내부 클래스라고 한다.

        getClass()로 로그 찍었을때 나오는 $표시는 무엇인가?
        내부 클래스에 익명이니까 이름을 만들어 준것이다!

    템플릿 메서드 패턴 - 적용 1
        제네릭은 타입에 대한 정보를 객체 생성시점이나 뒤로 미루는것 -> 반환 타입을 정의하는것

        로그에 출력할 메세지는 외부에서 파라미터로 전달 받는다.

        제네릭에서 반환 타입이 필요한데, 반환할 내용이 없으면 Void 타입을 사용하고 null을 반환하면 된다.
        참고로 제네릭은 기본 타입인 void, int 등을 선언할 수 없다.

    템플릿 메서드 패턴 - 적용 2


