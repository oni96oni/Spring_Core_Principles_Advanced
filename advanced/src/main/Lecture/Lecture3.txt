템플릿 메서드 패턴과 콜백 패턴
    템플릿 메서드 패턴 - 시작
        코드의 핵심기능과 부가기능

        핵심기능
            해당 객체가 제공하는 고유의 기능.

        부가기능
            핵심 기능을 보조하기 위해 제공되는 기능.

        ★★★변하는 것과 변하지 않는 것을 분리 - 좋은 애플리케이션의 설계의 이상적인 모습

        Controller, Service, Repository의 구조를 보면 로그 추적기를 사용하는 구조는 모두 동일 핵심 기능을 사용하는 코드만 다르다.

        여기서 핵심 기능부분은 변하고, 로그 추적기를 사용하는 부분은 변하지 않는 부분이다!
        이 둘을 분리해서 모듈화 해야하는데

        이런 문제 해결에 적합한 패턴이 템플릿 메서드 패턴이다.

    템플릿 메서드 패턴 - 예제 1
        변하는 부분은 비즈니스로직
        변하지 않는 부분 시간을 측정하는 부분(부가기능,공통기능)

        템플릿 메서드 패턴이 변하는 부분과 변하지 않는 부분을 분리할 수 있다.

    템플릿 메서드 패턴 - 예제 2
        추상 템플릿 -> 변하지 않는 로직들을 모아놓는다. 템플릿은 결국 '틀'이다!

        변하는 부분은 자식클래스로 만든다! 템플릿은 추상메서드이므로 상속받기 가능!

        템플릿 안에서 변하는 부분은 call() 메서드를 호출해서 처리한다!

        변하는 부분은 상속받은곳에서 마음껏 바꾸면서 구현하면되고
        안변하는 부분은 템플릿에 구현되어있으므로 건드릴 필요가 없다.

        관심사를 분리하여 변하는 부분의 범위를 최소화하여 유연성을 높이고 재사용성을 높인다.

    템플릿 메서드 패턴 - 예제 3
        익명 내부 클래스 사용하기!

        템플릿 메서드 패턴은 클래스를 계속 만들어야 하는 단점이 있다! 익명 내부 클래스를  사용하면 이런 단점을 보완할 수 있다.

        객체 인스턴스를 생성하면서 동시에 생성할 클래스를 상속받은 자식 클래스를 정의할 수 있다.

        이름 없고 내부에서 선언되어가지고 익명 내부 클래스라고 한다.

        getClass()로 로그 찍었을때 나오는 $표시는 무엇인가?
        내부 클래스에 익명이니까 이름을 만들어 준것이다!

    템플릿 메서드 패턴 - 적용 1
        제네릭은 타입에 대한 정보를 객체 생성시점이나 뒤로 미루는것 -> 반환 타입을 정의하는것

        로그에 출력할 메세지는 외부에서 파라미터로 전달 받는다.

        제네릭에서 반환 타입이 필요한데, 반환할 내용이 없으면 Void 타입을 사용하고 null을 반환하면 된다.
        참고로 제네릭은 기본 타입인 void, int 등을 선언할 수 없다.

    템플릿 메서드 패턴 - 적용 2
        좋은 설게란?
        변경이 일어날 때 자연스럽게 드러난다.
        모듈화를 해놓지 않았다면 변경할 때 마다 엄청나게 많은 부분들이 변경되어야 한다.
        로그를 남기는 로직을 변경해야 한다면? -> 추상템플릿의 public T execute(String message) 이부분만 변경하면 된다.

        단일 책임 원칙(SRP)
        로그를 남기는 부분에 단일 책임 원칙을 지킨것이다. 변경 지점을 하나로 모아서 변겨에 쉽게 대처할 수 있는 구조를 만든것이다.

        단순히 소스코드 몇줄 줄이는게 전부가 아니다. 여러 코드에 있는 변경점들을 하나로 모아놓은것!

    템플릿 메서드 패턴 - 정의
        작업에서 알고리즘의 골격을 정의하고 이룹 단계를 하위 클래스로 연기합니다.
        템플릿 메서드를 사용하면 하위 클래스가 알고리즘의 구조를 변경하지 않고도 알고리즘의 특정 단계를 재정의 할 수 있다.

        부모 클래스에 알고리즘의 골격인 템플릿을 정의
        변경되는 로직은 자식 클래스에 정의

        이렇게 되면 자식 클래스가 알고리즘의 전체 구조를 변경하지 않고, 특정 부분만 재정의할 수 있다.
        결국 상속과 오버라이딩을 통한 다형성으로 문제를 해결하는 것이다.

        템플릿 메서드 패턴은 상속을 사용 -> 상속의 단점을 안고간다. -> 자식 클래스가 부모 클래스와 컴파일 시점에 강하게 결합되는 문제
        의존 관계에 대한 문제가 발생한다. 자식 클래스 입장에서는 부모 클래스의 기능을 전혀 사용핮 ㅣ않는다.

        화살표의 의미가 이 클래스가 부모 클래스에게 의존한다는 뜻 -> 부모 클래스에서 변경 -> 자식 클래스에서도 변경
        영향을 받을 수 밖에 없다.

        자식 클래스 입장에서 부모 클래스의 기능을 전혀 사용하지 않는데, 부모 클래스를 알아야 한다. 이것은 좋은설계가 아니다!

        이런 점을 개선하려면?!?!

        상속보다 위임! 템플릿 메서드 패턴과 비슷한 역할을 하면서 상속의 단점을 제거할 수 있는 전략패턴 사용하자

    전략 패턴 - 시작
        동일한 문제(핵심기능, 부가기능을 구분하는)를 전략 패턴을 사용해서 해결해 보자!

    전략 패턴 - 예제 1
        전략 패턴은 변하지 않는 부분을 Context라는곳에 두고 변하는 부분을 Strategy라는 인터페이스를 만들고
        해당 인터페이스를 구현하도록 해서 문제를 해결! 위임으로 문제를 해결하는 것이다!
        Context는 변하지 않는 템플릿역할, Strategy는 변하는 알고리즘 역할을 한다!

        알고리즘 제품군(Strategy)를 정의하고 각각을 캡슐화하여 상호 교환 가능하게 만드는것!
        전략을 사용하면 알고리즘을 사용하는 클라이언트와 독립적으로 알고리즘을 변경할 수 있다.

        핵심은 Context는 Strategy의 인터페이스에만 의존한다. 그래서 Strategy의 구현체를 변경하거나 새로 만들어도
        Context코드에는 영향을 주지 않는다!

        스프링에서 의존관계 주입에서 사용하는 방식이 바로 전략패턴이다.

        인터페이스에 의존으로 인해서 영향을 받을일이 줄어들었다.

    전략 패턴 - 예제 2
        익명 내부 클래스를 사용해보기

        익명 내부 클래스를 람다로 변경할 수 있다 인터페이스에 메서드가 1개만 있으면 된다.

        이 방식의 단점은 Context와 Strategy를 조립한 이후에는 전략을 변경하기가 번거롭다.
        물론 Context에 setter를 제공해서 Strategy를 넘겨 받아 변경하면 되지만
        Context를 싱글톤으로 사용할 때는 동시성 이슈 등 고려할 점이 많다.

    전략 패턴 - 예제 3
        Context의 필드에 Strategy를 주입하는 방식에서
        전략을 실행할때 직접 파라미터로 전달해보자

        선 조립 후 실행하는 방식에서 실행ㅇ할 때마다 전략을 인수로 전달한다.

        따라서 이전 방식과 비교해서 원하는 전략을 더욱 유연하게 변경할 수 있다.

        단점은 실행할 때 마다 전략을 계속 지정해 주어야 한다.

        ★★템플릿
        우리가 해결하고 싶은 문제는 변하는 부분과 변하지 않는 부분을 분리하는것!!!
        변하지 않는 부분 -> 템플릿
        그 템플릿 안에서 변하는 부분에 약간 다른 코드 조각을 넘겨서 실행하는 것이 목적이다.

    템플릿 콜백 패턴 - 시작
        ★★콜백이란?
            다른 코드의 인수로서 넘겨주는 실행 가능한 코드

        콜백을 넘겨받은 코드는 코드를 바로 실행할 수도 있고, 아니면 나중에 실행할 수도 있다.

        자바 8 이전에는 익명 내부 클래스 사용, 8 이후에는 람다 사용

    템플릿 콜백 패턴 - 예제
        ContextV2와 내용이 같고 이름만 다르다.
        Context -> Template
        Strategy -> Callback

    템플릿 콜백 패턴 - 적용

    정리
        원본코드를 손대지 않고 로그추적기를 적용하기 위해서는 프록시 개념이 필요하다!

        부모클래스에 템플릿을 넣어놓고 자식이 상속받아서 해결 변하는 부분은 자식 안변하는 부분은 부모클래스

        상속 -> 부모의 변화는 자식의 변화로 연쇄작용이 일어난다는 단점 -> 전략 패턴 -> 상속이 아니라 위임

