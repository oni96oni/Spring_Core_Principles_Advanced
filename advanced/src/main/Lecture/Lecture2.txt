쓰레드 로컬 - ThreadLocal
    필드 동기화 - 개발
        로그 추적기를 필드 동기화해보자.

        필드 동기화란???

    필드 동기화 - 적용
        수동 빈 등록 - LogTraceConfig -> @Configuration -> @Component -> @Bean '싱글톤'으로 등록!

        인터페이스를 주입받으므로 기존의 파라미터로 값을 넘겨주던 방식을 변경! beginSync에서 begin사용

    필드 동기화 - 동시성 문제
        빠르게 요청시 동시성 문제 발생! 완전히 로그가 꼬여버린다.

        ★★★FieldLogTrace는 싱글톤으로 등록된 스프링 빈이기 때문! 이렇게 하나만 있는 인스턴스의 필드를
        여러 쓰레드가 동시에 접근하기 때문에 문제가 발생!!!

    동시성 문제 - 예제 코드
        Thread-A 입장에서 저장한 데이터와 조회한 데이터가 다른 문제가 발생!

        이처럼 여러 쓰레드가 동시에 같은 인스턴스의 필드 값을 변경하면서 발생하는 문제를 동시성 문제라 한다!!!

        트래픽이 점점 많아 질수록 자주 발생한다.
        스프링 처럼 싱글톤 객체의 필드를 변경하며 사용할 때 이러한 동시성 문제를 조심해야 한다.

        지역변수에서는 발생하지 않는다! 지역변수는 쓰레드마다 각각 다른 메모리 영역이 할당된다!

        동시성 문제가 발생하는 곳은 같은 인스턴스의 필드! 또는 static 같은 공용 필드에 여러 쓰레드가 접근할 때 발생한다.

        특히 읽기만 해서는 발생 x , 값을 변경하기 때문에 발생한다!

        싱글톤 객체의 필드를 사용하면서 동시성 문제를 해결하려면 -> 쓰레드 로컬이 해결 방법!

    ThreadLocal - 소개
        쓰레드 로컬 == 해당 쓰레드만 접근할 수 있는 특별한 저장소!

        java.lang.ThreadLocal 클래스를 사용하면 쓰레드 로컬을 만들 수 있다.

    ThreadLocal - 예제 코드
        ThreadLocal.set : 저장
        ThreadLocal.get : 조회
        ThreadLocal.remove() : 삭제

        해당 쓰레드가 쓰레드 로컬을 모두 사용하고 나면 remove()를 호출해서 쓰레드 로컬에 저장된 값을 제거해주어야 한다.

        변수 한꺼번에 변경할때도 쉬프트 f6을 사용한다.

        쓰레드 로컬 덕분에 쓰레드 마다 각각 별도의 저장소를 갖게 되었다!
        이러면 동시성 문제 해결 끝? 다른문제는 없을까???

        쓰레드마다 전용 보관소가 생기니까 비용의 부담이 되지 않을까?

    쓰레드 로컬 동기화 - 개발
        로컬을 다 쓰고 remove()를 해줘야 저장소에 남아있는걸 지울 수 있다.

    쓰레드 로컬 동기화 - 적용
        LogTraceConfig만 변경해서 내가 원하는 어플리케이션으로 변경할 수 있는 것은 매우 큰 장점같다.

    쓰레드 로컬 - 주의사항
        쓰레드 로컬의 값을 사용 후 제거하지 않고 was처럼 쓰레드 풀을 사용하는 경우 심각한 문제 발생!

        쓰레드 풀에서는 어떤 쓰레드가 사용될지는 모른다!

        남아 있는 로컬을 남겨두면 다른 쓰레드가 접근하여 그 데이터를 사용할 수 있다!

        사용자 B가 정보 조회를 요청했는데 사용자 A의 정보를 보게되는 경우가 발생할 수 있다.

    정리
        넘기는 파라미터 때문에 동기화(전역 변수 사용)

