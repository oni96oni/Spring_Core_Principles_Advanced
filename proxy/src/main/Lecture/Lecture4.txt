프록시 패턴과 데코레이션 패턴
    프로젝트 생성

    예제 프로젝트 만들기 v1
        다양한 상황에서 프록시 사용법 이해가 목적!

        v1 - 인터페이스와 구현클래스 - 스프링 빈 수동 등록
        v2 - 인터페이스 없는 구체 클래스 - 스프링 빈 수동 등록
        v3 - 컴포넌트 스캔으로 스프링 빈 자동 등록

        @Controller 또는 @RequestMapping 애노테이션이 타입에 있으면 스프링 컨트롤러로 인식한다.
        스프링 컨트롤러로 인식해야, HTTP URL이 매핑되고 동작한다. 이 애노테이션은 인터페이스에 사용해도 된다.

        @SpringBootApplication에서 scanBasePackages를 지정하면
        컴포넌트 스캔을 시작할 위치를 지정하는것으로 해당 패키지와 그 하위 패키지를 컴포넌트 스캔한다.
        지정하지 않으면? ProxyApplication이 있는 패키지와 그 하위 패키지를 스캔한다.

    예제 프로젝트 만들기 v2
        인터페이스가 없는것을 구체 클래스라고한다.

    예제 프로젝트 만들기 v3

    요구사항 추가
        결과 적으로 로그를 남기고 싶은 클래스가 수백개라면 수백개의 클래스를 모두 고쳐야 한다.
        ★로그를 남길 때 기존 원본 코드를 변경해야 한다는 사실 그 자체가 개발자에게 가장 큰 문제!

        원본 코드를 전혀 수정하지 않고, 로그 추적기를 적용해라
        특정 메서드는 로그를 출력하지 않는 기능
            보안상 일부는 로그를 출력하면 안된다.
        다양한 케이스에 적용가능해야한다.
            v1 - 인터페이스가 있는 구현 클래스에 적요ㅕㅇ
            v2 - 인터페이스가 없는 구체 클래스에 적용
            v3 - 컴포넌트 스캔 대상에 기능 적용

        가장 어려운 문제 -> 원본 코드를 전혀 수정하지 않고, 로그 추적기를 도입 하는것이다.
        프록시의 개념을 먼저 이해해야 한다.

    프록시, 프록시 패턴, 데코레이터 패턴 - 소개
        클라이언트 : 서버에 필요한것을 요청
        서버 : 클라이언트의 요청을 처리

        프록시는 대리자!! 클라이언트를 대신해서 서버에 요청을 보내고, 서버의 결과를 받아서 클라이언트에게 전달한다.

        프록시를 통해서 ★접근 제어, ★캐싱, ★부가기능 추가, 프록시 체인등 다양한 기능을 제공한다.

        DI를 통해 클라이언트 코드의 변경 없이 유연하게 프록시를 주입할 수 있다는것이 중요한점이다!

        접근제어
            권한에 따른 접근 차단 - 권한을 체크(권한이 없으면 접근 불가하게)
            캐싱 - 캐시에 데이터가 있으면 캐시에서 꺼내고 접근을 안하게 한다.
            지연 로딩 - jpa에서 자주나옴, 실제로 데이터를 사용할 때 까지 로딩을 지연시킨다.

        부가 기능 추가
            원래 서버가 제공하는 기능에 더해서 부가 기능을 수행한다.
                요청 값이나, 응답 값을 중간에 변형하거나 실행 시간을 측정해서 추가 로그를 남기는것들 가능

        프록시 패턴과 데코레이터 패턴은 의도로 구분을 한다!

        접근 제어가 목적이면 프록시패턴
        부가 기능 추가(새로운 기능추가)가 목적이면 데코레이터 패턴

        모양만으로는 이 두개의 디자인 패턴을 구분하기가 어렵다.

        프록시라는 개념은 클라이언트 서버라는 큰 개념안에서 자연스럽게 발생할 수 있다. 객체안에서의 개념도,
        웹 서버에서의 프록시도 있다. 규모의 차이가 있을 뿐 근본적인 역할은 같다.

    프록시 패턴 - 예제 코드 1
        프록시 패턴은 프록시를 사용 하는 여러가지 패턴중에 하나이다!

        한번 정하면 변하지 않는 데이터라면 어딘가에 보관해두고 이미 조회한 데이터를 사용하는 것이 성능상 좋다.
        -> 캐시

        캐시도 접근 자체를 제어하는 기능 중 하나이다.

        이미 개발된 로직을 전혀 수정하지 않고, 프록시 객체를 통해서 캐시를 적용해보자.

    프록시 패턴 - 예제 코드 2
        realSubject를 호출하고 결과를 캐시에 저장
        그다음부터는 캐시값이 있기때문에 즉시반환!
        테스트 시간을 보면 1초 - 즉시 - 즉시 걸리는것을 확인할 수 있다.

        프록시 패턴의 핵심은 RealSubject 코드와 클라이언트 코드를 전혀! 변경하지 않고
        프록시를 도입해서 접근 제어를 했다는 점이다.

        물론 실제 클라이언트 입장에서는 프록시 객체가 주입되었는지, 실제 객체가 주입되었는지 알지 못한다.

    데코레이터 패턴 - 예제 코드 1

    데코레이터 패턴 - 예제 코드 2
        프록시를 활용해서 부가 기능 추가 -> 데코레이터 패턴

        요청 값이나, 응답 값을 중간에 변형하거나 실행 시간을 측정해서 추가 로그를 남기는것

    데코레이터 패턴 - 예제 코드 3
        데코레이터 패턴에다가 데코레이터 패턴을 하나 더 끼워넣어보는 예시 코드

        프록시는 체인이 될 수 있다.

        ★★★클라이언트는 코드를 전혀 건드리지않는다!!!
        우리 마음대로 클라이언트와 서버사이에 여러가지 프록시를 넣음으로 써 다양한 기능을 추가할 수 있다
        코드의 변경없이!

    프록시 패턴과 데코레이터 패턴 정리
        Decorator는 꾸며줄 대상이 항상 필요하다. 혼자서는 스스로는 존재할 수 없다.
        내부에 호출대상인 component를 가지고 있어야 하는데, 이러한 부분이 중복된다.

        디자인 패턴을 공부할때는 의도(intent)가 중요하다!

        모양이 똑같고, 상황에 따라 정말 같을 때도 있는데 이럴때는 의도로 구분을한다!
        프록시 -> 다른 객체 접근을 제어 하기위한 대리자를 제공
        데코레이터 -> 객체에 추가 책임(기능)을 동적으로 추가, 기능확장을 위한 유연한 대안 제공

    인터페이스 기반 프록시 - 적용
        프록시를 사용하면 기존 코드를 전혀 수정하지 않고 로그 추적 기능을 도입할 수 있다는것이 핵심이다!

        스프링 빈으로 실제 객체 대신에 프록시 객체를 등록했기 때문에, 앞으로 스프링빈을 주입 받으면 실제 객체 대신에 프록시 객체가 주입된다.

        프록시 객체 안에 실제 객체가 있다고 생각하자 없어지는게 아니야!

    구체 클래스 기반 프록시 - 예제 1
        인터페이스 없이 프록시를 적용할 수 있을까???

    구체 클래스 기반 프록시 - 예제 2
        클래스 기반 프록시를 도입해보자.

        자바의 다형성은 인터페이스를 구현하든, 클래스를 상속하든
        ★★★상위 타입만 맞으면 다형성이 적용된다. 인터페이스가 없어도 프록시를 만들 수 있다는 뜻이다!

        인터페이스나 클래스를 구분하지 않고 다형성이 적용된다
        즉, 인터페이스 없이도 프록시적용에 문제없다!

    구체 클래스 기반 프록시 - 적용
        상속받으면, 기본 생성자 아닌 생성자가 있으면 구현을 해줘야한다.

    인터페이스 기반 프록시와 클래스 기반 프록시
        프록시
            원본 코드를 전혀 변경하지 않고 v1, v2에 LogTrace 기능을 적용할 수 있었다

        인터페이스 기반 프록시 vs 클래스 기반 프록시
            클래스 기반 프록시는 해당 클래스에만 적용 가능, 인터페이스 기반 프록시는 인터페이스만 같으면 모든 곳에 적용 가능 하다.
            클래스 기반 프록시는 상속을 사용
                1. 부모 클래스의 생성자를 호출해야 한다.
                2. 클래스에 final 키워드가 붙으면 상속이 불가능하다.
                3. 메서드에 final 키워드가 붙으면 해당 메서드를 오버라이딩 할 수 없다.

            역할과 구현을 명확하게 나누기 때문에 프로그래밍 관점에서도 인터페이스 기반 프록시가 더 좋다.
            하지만 인터페이스가 필요하다는 그 자체가 단점이다. 인터페이스가 없을 수 있기 때문!

            추가로 캐스팅 관련해서 단점이 있는데 후술한다.
            다시 볼때는 어떤 단점이 있는지 알고있겠지?

            인터페이스를 도입하는 것은 구현을 변경할 가능성이 있을 때 효과적!!!
            실용적인 관점에서 인터페이스를 무조건 사용하는것은 올바르지 않다.

            핵심은 인터페이스가 항상 필요한건 아니다!

            현재 문제는 프록시 클래스를 너무 많이 만들어야 한다는점이 있다.
            하나만 만들어서 모든곳에 적용하는 방법은 없을까?
            -> 동적 프록시 기술이 해결!! 실시간으로 프록시를 만들어준다.

    정리
         클라이언트 입장에서는 서버가 일을하는지 프록시가 일을 하는지 몰라야한다!

         의도에 따라 프록시(접근 제어), 데코레이터(기능 추가)로 나뉜다.

         프록시를 적용하게되면 스프링 컨테이너에 실제 객체가 아니라 프록시객체를 등록하게 된다.
         실제 객체는 등록하면 안된다. 이렇게 해야 어디서 주입을 받는지 프록시가 주입이 된다.
         그 다음에 프록시 객체가 실제 객체를 호출하는 흐름

