동적 프록시 기술
    리플렉션
        프록시를 통해서 기존 코드를 변경하지 않고 기능을 추가할 수 있음 하지만 대상 클래스만큼 만들어야했던 단점이 존재!

        로그 추적기 기능의 프록시 클래스들의 소스코드는 거의 비슷한 모양이었다.

        JDK 동적 프록시 기술이나 CGLIB 같은 프록시 생성 오픈소스 기술을 활용하여
        프록시 객체를 동적으로 만들어낼 수 있다.

        리플렉션 기술을 사용하면 클래스나 메서드의 메타정보를 동적으로 획득하고, 코드도 동적으로 호출 가능

        메타정보란???

        리플렉션 기술이란???

        생각보다 비슷한 구조의 로직을 메서드로 뽑아서 공통화 하는것은 어렵다. 중간에 호출하는 메서드가 다르기 때문
        호출하는 부분만 동적으로 처리할 수 있다면 해결이 가능하다.
        -> 이럴때 리플렉션을 사용한다.
        (물론 여기서 람다를 사용해서 공통화 하는 것도 가능하다)

        Class.forName -> 클래스 메타정보 획득, 내부 클래스의 경우 구분을 위해 $ 사용
        위의 메서드를 통해서 얻은 클래스 정보로 메서드 메타정보를 얻을 수 있다.(getMethod("호출하려는 메서드명"))

        이렇게 메서드 정보를 획득해서 메서드를 호출하면 어떤효과?
        -> 클래스나 메서드 정보를 동적으로 변경할 수 있다 -> 공통 로직으로 추출 가능!
        당연히 method.invoke(target)을 사용할 때 호출할 클래스와 메서드 정보가 서로 다르면 예외가 발생한다.

        하지만 리플렉션은 가급적 사용x ! why??
        런타임에 동작하기 때문에, 컴파일 시점에 오류를 잡을 수 없다.

        메타정보를 얻어서, 메타정보를 바탕으로 동적으로 클래스와 메서드를 내 마음대로 사용하는것이
        리플렉션이다.

    JDK 동적 프록시 - 소개
        프록시의 로직은 같은데, 적용 대상의 차이만 존재 -> 적용대상에 따라 프록시 클래스도 무수히 증가
        -> 동적 프록시 기술로 해결

        JDK 동적 프록시는 인터페이스를 기반으로 프록시를 동적으로 만들어준다.
        -> 인터페이스가 필수!

    JDK 동적 프록시 - 예제 코드
        JDK 동적 프록시에 적용할 로직은 InvocationHandler 인터페이스를 구현해서 작성하면 된다.
        프록시가 사용하는 로직이라고 생각하자.

        ★★프록시는 항상 프록시가 호출할 대상이 있어야 한다.

        InvocationHandler를 구현함으로써 JDK 동적 프록시에 적용할 공통 로직을 개발할 수 있다.
        구현하면 invoke 메서드를 오버라이딩해야 하는데
        매개변수로 Object target : 동적 프록시가 호출할 대상
        args는 메서드 호출시 넘겨줄 인수이다.

        JDK 동적 프록시는
        프록시를 자동으로 만들어준다.
        InvocationHandler라는 것으로 프록시의 로직을 정의한다.

    JDK 동적 프록시 - 적용 1
